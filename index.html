<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nat drawGrid</title>
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<style>
    body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
            margin: 0 auto;
            transform: scale(0.75);
            transform-origin: center;
        }
</style>
<body>
    Seed: <input type="number" id="seedInput" value="1234">
    <button onclick="updateSeed()">Update Seed</button>
  <script>
let blk = 69
function updateSeed() {
            let inputVal = document.getElementById('seedInput').value;
            blk = parseInt(inputVal);
            setup();
        }


let OceanBreeze = ["#005f73", "#0a9396", "#94d2bd", "#e9d8a6", "#ee9b00"];
let SunsetGlow = ["#ff9f1c", "#ffbf69", "#ffffff", "#cbf3f0", "#2ec4b6"];
let ForestRetreat = ["#2b2d42", "#8d99ae", "#edf2f4", "#ef233c", "#d90429"];
let VintageCharm = ["#6d6875", "#b5838d", "#e5989b", "#ffb4a2", "#ffcbf2"];
let SoothingLavender = ["#b56576", "#e56b6f", "#eaac8b", "#c3aed6", "#d4a5a5"];
let CitrusBurst = ["#ffba08", "#faa307", "#f48c06", "#e85d04", "#dc2f02"];
let IcyElegance = ["#d8f3dc", "#b7e4c7", "#95d5b2", "#74c69d", "#52b788"];
let DesertSpice = ["#cc8b86", "#f5d0c5", "#e6b8a2", "#c2948a", "#c46d5e"];
let RoyalIndigo = ["#4a4e69", "#9a8c98", "#c9ada7", "#f2e9e4", "#c9ada7"];
let MintyFreshness = ["#b5e48c", "#99d98c", "#76c893", "#52b69a", "#34a0a4"];
let WarmAndCool = ["#FF6B6B", "#F7B801", "#FDE74C", "#C5E4E7", "#DBE2EF"];
let EarthyTones = ["#264653", "#2A9D8F", "#E9C46A", "#F4A261", "#E76F51"];
let MutedElegance = ["#355070", "#6D597A", "#B56576", "#E56B6F", "#EAAC8B"];
let FreshAndVibrant = ["#1A535C", "#4ECDC4", "#F7FFF7", "#FF6B6B", "#FFE66D"];
let ModernAndBold = ["#2B2D42", "#8D99AE", "#EDF2F4", "#EF233C", "#D90429"];
let DynamicContrast = ["#086375", "#F26419", "#F6AE2D", "#F6F7EB", "#33658A"];

let palettes = {
    OceanBreeze,
    SunsetGlow,
    ForestRetreat,
    VintageCharm,
    SoothingLavender,
    CitrusBurst,
    IcyElegance,
    DesertSpice,
    RoyalIndigo,
    MintyFreshness,
    WarmAndCool,
    EarthyTones,
    MutedElegance,
    FreshAndVibrant,
    ModernAndBold,
    DynamicContrast
};



let currentPaletteIndex;
let canvassize;
let colMode
let m
let i
let j
let m1
let t1
let t


let baseSquareSize



let canvas;
let canvasWidth, canvasHeight;
let seed

function setup() {
  pixelDensity(2);
  imageMode(CENTER);
  rectMode(CENTER);
  noLoop();
  drawGrid(); 
}

function draw() {
  
}

function drawGrid() {
  seed = blk;
  randomSeed(seed);
  noiseSeed(seed);
  canvassize = random(["square", "landscape", "portrait"]);
  let paletteNames = Object.keys(palettes);
  let consistentIndex = floor(random() * paletteNames.length);
  let currentPaletteName = paletteNames[consistentIndex];
  currentPaletteIndex = palettes[currentPaletteName];
  
  switch (canvassize) {
    case "square":
      canvasWidth = 830;
      canvasHeight = 830;
      break;
    case "landscape":
      canvasWidth = 830;
      canvasHeight = 690;
      break;
    case "portrait":
      canvasWidth = 690;
      canvasHeight = 830;
      break;
  }

  
  if (canvas) {
    canvas.remove(); 
  }
  canvas = createCanvas(canvasWidth, canvasHeight);
  background(242, 237, 220);

  colMode = random(["columns", "rows", "flower", "centralWave", "diagonal", "diagonalRL", "noise"]);
  
  v = createGraphics(canvasWidth - 40, canvasHeight - 40);
  v.imageMode(CENTER);
  v.background(242, 237, 220);
  v.noStroke();
  noStroke();

  let percent = 40 / 100;
  graphics = createGraphics(width, height);
  graphics.stroke(255, 10 / 100 * 255);

  for (i = 0; i < graphics.width * graphics.height * percent; i++) {
    graphics.point(random(graphics.width), random(graphics.height));
  }

  
  print("canvas = " + canvassize);
  print("ColorPattern = " + colMode);
  print("Palette = " + currentPaletteName);
  let patternChoice = random(["ripple", "diamond", "noise", "normal"]);

  if (patternChoice === "ripple" && colMode === "centralWave") {
    let colModesExcludingCentralWave = ["flower", "diagonal", "diagonalRL", "columns", "rows", "noise"];
    colMode = random(colModesExcludingCentralWave);
  }

  if (patternChoice === "noise" && colMode === "centralWave") {
    let colModesExcludingCentralWave = ["flower", "diagonal", "diagonalRL", "columns", "rows", "noise"];
    colMode = random(colModesExcludingCentralWave);
  }




  recty(patternChoice);
  image(v, width / 2, height / 2);
  image(graphics, width / 2, height / 2);
  print(patternChoice)
}


function recty(patternChoice) {
  let cols, rows;
  switch (canvassize) {
    case "square":
      cols = 23;
      rows = 23;
      break;
    case "landscape":
      cols = 23;
      rows = 19;
      break;
    case "portrait":
      cols = 19;
      rows = 23;
      break;
  }

  v.background(242, 237, 220);

  let baseSquareSize = 20;
  let xOffset = (v.width - (cols * baseSquareSize)) / (cols + 1);
  let yOffset = (v.height - (rows * baseSquareSize)) / (rows + 1);
  let noiseScale = 0.1; 

  let rippleScale = random([1,3,5]);
  let rippleSpeed = PI / random([2,3]);
  let colorsForRows = [];
  let colorsForColumns = [];
  let wavecolor, flowercolor, noisecolor, diagonalColor, diagonalRLColor;
  if (colMode === "rows") {
    
    for (let j = 0; j < rows; j++) {
      let colorIndex = floor(random(currentPaletteIndex.length));
      colorsForRows[j] = currentPaletteIndex[colorIndex];
    }
  } else if (colMode === "columns") {
   
    for (let i = 0; i < cols; i++) {
      let colorIndex = floor(random(currentPaletteIndex.length));
      colorsForColumns[i] = currentPaletteIndex[colorIndex];
    }
  }

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = xOffset + i * (baseSquareSize + xOffset);
      let y = yOffset + j * (baseSquareSize + yOffset);
      
      let squareSize = baseSquareSize;
    let diamondSize = Math.min(cols, rows) / 1.7;
    let distance = (Math.abs(i - cols / 2) + Math.abs(j - rows / 2)) / diamondSize;

     
      if (patternChoice === "noise") {
        
        let noiseValue = noise(i * noiseScale, j * noiseScale);
        squareSize *= map(noiseValue, 0, 1, 0.3, 1.5);
      } else if (patternChoice === "ripple") {
        
        let distanceFromCenter = dist(i, j, cols / 2, rows / 2);
        squareSize *= (1 + 0.5 * sin(distanceFromCenter * rippleScale +  seed * rippleSpeed));
      } else if (patternChoice === "diamond") {
        let distance = (Math.abs(i - cols / 2) + Math.abs(j - rows / 2)) / diamondSize;
        if (distance <= 1) {
          squareSize *= (1 - distance); 
        }
      }


      
      

      
      if (colMode === "centralWave") {
  let centerX = cols / 2;
  let centerY = rows / 2;
  let maxDistance = dist(0, 0, centerX, centerY);

  
  let colorIndex1 = Math.floor(random(currentPaletteIndex.length));
  let colorIndex2 = colorIndex1;
  while (colorIndex2 === colorIndex1) {
    colorIndex2 = Math.floor(random(currentPaletteIndex.length));
  }

  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = xOffset + i * (baseSquareSize + xOffset);
      let y = yOffset + j * (baseSquareSize + yOffset);

      
      let distance = dist(i, j, centerX, centerY);
      
      
      let frequency = 2 * Math.PI / maxDistance; 
      let waveValue = (Math.sin(distance * frequency) + 1) / 2; 
     
      let color1 = color(currentPaletteIndex[colorIndex1]);
      let color2 = color(currentPaletteIndex[colorIndex2]);
      wavecolor = lerpColor(color1, color2, waveValue);

      v.fill(wavecolor);
      v.rect(x, y, baseSquareSize, baseSquareSize);
    }
  }
} else if (colMode === "flower") {
    let angle = atan2(j - rows / 2, i - cols / 2) + PI;
    let distance = dist(i, j, cols / 2, rows / 2);
    let colorIndex = (angle / (2 * PI)) * currentPaletteIndex.length;
    let gradientIndex = (distance / max(cols / 2, rows / 2)) * currentPaletteIndex.length;

    
    colorIndex = floor(colorIndex) % currentPaletteIndex.length;
    gradientIndex = floor(gradientIndex) % currentPaletteIndex.length;

    
    if (currentPaletteIndex[colorIndex] && currentPaletteIndex[gradientIndex]) {
        flowercolor = lerpColor(color(currentPaletteIndex[colorIndex]), color(currentPaletteIndex[gradientIndex]), 0.5);
    } else {
        
        flowercolor = color('#000000');
    }
      } else if (colMode === "diagonal") {
        let diagonalIndex = (i + j) % currentPaletteIndex.length;
        diagonalColor = currentPaletteIndex[diagonalIndex];
      } else if (colMode === "diagonalRL") { 
        let diagonalIndex = (cols - i + j - 1) % currentPaletteIndex.length;
        diagobalRLcolor = currentPaletteIndex[diagonalIndex];
      } else if (colMode === "noise") {
        noiseVal = noise(x * 0.01, y * 0.01);
        colorIndex = Math.floor(noiseVal * currentPaletteIndex.length);
        noisecolor = currentPaletteIndex[colorIndex];
      }

      let fillColor;
      switch (colMode) {
        case "rows":
          fillColor = colorsForRows[j]
          break;
        case "columns":
        fillColor = colorsForColumns[i]
          break;
          case "centralWave":
          fillColor = wavecolor
          break;
          case "flower":
          fillColor = flowercolor
          break;
          case "diagonal":
          fillColor = diagonalColor
          break;
          case "diagonalRL":
          fillColor = diagobalRLcolor
          break;
          case "noise":
          fillColor = noisecolor
          break;
        
      }

      

      
      v.fill(50); 
      v.rect(x + 5, y + 5, squareSize, squareSize);
      v.fill(fillColor);
      v.rect(x, y, squareSize, squareSize);
    }
  }
}

</script>
</body>
</html>
